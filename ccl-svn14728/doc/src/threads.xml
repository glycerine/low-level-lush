<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
          <!ENTITY rest "<varname>&amp;rest</varname>">
          <!ENTITY key "<varname>&amp;key</varname>">
          <!ENTITY optional "<varname>&amp;optional</varname>">
          <!ENTITY body "<varname>&amp;body</varname>">
          <!ENTITY aux "<varname>&amp;aux</varname>">
          <!ENTITY allow-other-keys "<varname>&amp;allow-other-keys</varname>">
          <!ENTITY CCL "Clozure CL">
          ]>

<chapter id="Programming-with-Threads">
  <title>Programming with Threads</title>

  <sect1 id="Threads-overview">
    <title>Threads Overview</title>

    <para>&CCL; provides facilities which enable multiple threads
      of execution (<emphasis>threads</emphasis>, sometimes called
      <emphasis>lightweight processes</emphasis> or just
      <emphasis>processes</emphasis>, though the latter term shouldn't
      be confused with the OS's notion of a process) within a lisp
      session. This document describes those facilities and issues
      related to multithreaded programming in &CCL;.</para>

    <para>Wherever possible, I'll try to use the term "thread" to
      denote a lisp thread, even though many of the functions in the
      API have the word "process" in their name. A
      <emphasis>lisp-process</emphasis> is a lisp object (of type
      CCL:PROCESS) which is used to control and communicate with an
      underlying <emphasis>native thread</emphasis>. Sometimes, the
      distinction between these two (quite different) objects can be
      blurred; other times, it's important to maintain.</para>
    <para>Lisp threads share the same address space, but maintain
      their own execution context (stacks and registers) and their own
      dynamic binding context.</para>
    
    <para>Traditionally, &CCL;'s threads have been
      <emphasis>cooperatively scheduled</emphasis>: through a
      combination of compiler and runtime support, the currently
      executing lisp thread arranged to be interrupted at certain
      discrete points in its execution (typically on entry to a
      function and at the beginning of any looping construct). This
      interrupt occurred several dozen times per second; in response,
      a handler function might observe that the current thread had
      used up its time slice and another function (<emphasis>the lisp
        scheduler</emphasis>) would be called to find some other thread
      that was in a runnable state, suspend execution of the current
      thread, and resume execution of the newly executed thread.  The
      process of switching contexts between the outgoing and incoming
      threads happened in some mixture of Lisp and assembly language
      code; as far as the OS was concerned, there was one native
      thread running in the Lisp image and its stack pointer and other
      registers just happened to change from time to time.</para>
    <para>Under &CCL;'s cooperative scheduling model, it was
      possible (via the use of the CCL:WITHOUT-INTERRUPTS construct)
      to defer handling of the periodic interrupt that invoked the
      lisp scheduler; it was not uncommon to use WITHOUT-INTERRUPTS to
      gain safe, exclusive access to global data structures. In some
      code (including much of &CCL; itself) this idiom was very
      common: it was (justifiably) believed to be an efficient way of
      inhibiting the execution of other threads for a short period of
      time.</para>

    <para>The timer interrupt that drove the cooperative scheduler
      was only able to (pseudo-)preempt lisp code: if any thread
      called a blocking OS I/O function, no other thread could be
      scheduled until that thread resumed execution of lisp code. Lisp
      library functions were generally attuned to this constraint, and
      did a complicated mixture of polling and "timed blocking" in an
      attempt to work around it. Needless to say, this code is
      complicated and less efficient than it might be; it meant that
      the lisp was a little busier than it should have been when it
      was "doing nothing" (waiting for I/O to be possible.)</para>

    <para>For a variety of reasons - better utilization of CPU
      resources on single and multiprocessor systems and better
      integration with the OS in general - threads in &CCL; 0.14 and
      later are <emphasis>preemptively scheduled. </emphasis>In this
      model, lisp threads are native threads and all scheduling
      decisions involving them are made by the OS kernel. (Those
      decisions might involve scheduling multiple lisp threads
      simultaneously on multiple processors on SMP systems.) This
      change has a number of subtle effects:</para>

    <itemizedlist>
      <listitem>
	    <para>it is possible for two (or more) lisp threads to be
	      executing simultaneously, possibly trying to access and/or
	      modify the same data structures. Such access really should
	      have been coordinated through the use of synchronization
	      objects regardless of the scheduling modeling effect;
	      preemptively scheduled threads increase the chance of things
	      going wrong at the wrong time and do not offer
	      lightweight alternatives to the use of those synchronization
	      objects.</para>
	  </listitem>
      <listitem>
	    <para>even on a single-processor system, a context switch
	      can happen on any instruction boundary. Since (in general)
	      other threads might allocate memory, this means that a GC can
	      effectively take place at any instruction boundary. That's
	      mostly an issue for the compiler and runtime system to be
	      aware of, but it means that certain practices(such as trying
	      to pass the address of a lisp object to foreign code)that
	      were always discouraged are now discouraged
	      ... vehemently.</para>
	  </listitem>
      <listitem>
	    <para>there is no simple and efficient way to "inhibit the
	      scheduler"or otherwise gain exclusive access to the entire
	      CPU.</para>
	  </listitem>
      <listitem>
	    <para>There are a variety of simple and efficient ways
	      to synchronize access to particular data
	      structures.</para>
	  </listitem>
    </itemizedlist>
    <para>As a broad generalization: code that's been aggressively
      tuned to the constraints of the cooperative scheduler may need
      to be redesigned to work well with the preemptive scheduler (and
      code written to run under &CCL;'s interface to the native
      scheduler may be less portable to other CL implementations, many
      of which offer a cooperative scheduler and an API similar to
      &CCL; (&lt; 0.14) 's.) At the same time, there's a large
      overlap in functionality in the two scheduling models, and it'll
      hopefully be possible to write interesting and useful MP code
      that's largely independent of the underlying scheduling
      details.</para>
    <para>The keyword :OPENMCL-NATIVE-THREADS is on *FEATURES* in
      0.14 and later and can be used for conditionalization where
      required.</para>
  </sect1>

  <sect1 id="Intentionally--Missing-Functionality">
    <title>(Intentionally) Missing Functionality</title>
    <para>Much of the functionality described above is similar to
      that provided by &CCL;'s cooperative scheduler, some other
      parts of which make no sense in a native threads
      implementation.</para>
    <itemizedlist>
      <listitem>
	    <para>PROCESS-RUN-REASONS and PROCESS-ARREST-REASONS were
	      SETFable process attributes; each was just a list of
	      arbitrary tokens. A thread was eligible for scheduling
	      (roughly equivalent to being "enabled") if its arrest-reasons
	      list was empty and its run-reasons list was not. I don't
	      think that it's appropriate to encourage a programming style
	      in which otherwise runnable threads are enabled and disabled
	      on a regular basis (it's preferable for threads to wait for
	      some sort of synchronization event to occur if they can't
	      occupy their time productively.)</para>
	  </listitem>
      <listitem>
	    <para>There were a number of primitives for maintaining
	      process queues;that's now the OS's job.</para>
	  </listitem>
      <listitem>
	    <para>Cooperative threads were based on coroutining
	      primitives associated with objects of type
	      STACK-GROUP. STACK-GROUPs no longerexist.</para>
	  </listitem>
    </itemizedlist>
  </sect1>


  <sect1 id="Implementation-Decisions-and-Open-Questions">
    <title>Implementation Decisions and Open Questions</title>
    <sect2 id="Thread-Stack-Sizes">
      <title>Thread Stack Sizes</title>
      <para>When you use MAKE-PROCESS to create a thread, you can
        specify a stack size. &CCL; does not impose a limit on the stack
        size you choose, but there is some evidence that choosing a
        stack size larger than the operating system's limit can cause
        excessive paging activity, at least on some operating
        systems.</para>
      <para>The maximum stack size is operating-system-dependent. You
        can use shell commands to determine what it is on your
        platform. In bash, use "ulimit -s -H" to find the limit; in
        tcsh, use "limit -h s".</para>
      <para>This issue does not affect programs that create threads
        using the default stack size, which you can do either by
        specifying no value for the :stack-size argument to
        MAKE-PROCESS, or by specifying the value
        CCL::*default-control-stack-size*.</para>
      <para>If your program creates threads with a specified stack size,
        and that size is larger than the OS-specified limit, you may want
        to consider reducing the stack size in order to avoid possible
        excessive paging activity.</para>
    </sect2>
    <sect2>
      <title> As of August 2003:</title>
      <itemizedlist>
        <listitem>
	      <para>It's not clear that exposing
	        PROCESS-SUSPEND/PROCESS-RESUME is a good idea: it's not clear
	        that they offer ways to win, and it's clear that they offer
	        ways to lose.</para>
	    </listitem>
        <listitem>
	      <para>It has traditionally been possible to reset and enable
	        a process that's "exhausted" . (As used here, the
	        term "exhausted" means that the process's initial function
	        has run and returned and the underlying native thread has
	        been deallocated.) One of the principal uses of PROCESS-RESET
	        is to "recycle" threads; enabling an exhausted process
	        involves creating a new native thread (and stacks and
	        synchronization objects and ...),and this is the sort of
	        overhead that such a recycling scheme is seeking to avoid. It
	        might be worth trying to tighten things up and declare that
	        it's an error to apply PROCESS-ENABLE to an exhausted thread
	        (and to make PROCESS-ENABLE detect this error.)</para>
	    </listitem>
        <listitem>
	      <para>When native threads that aren't created by &CCL;
	        first call into lisp, a "foreign process" is created, and
	        that process is given its own set of initial bindings and set
	        up to look mostly like a process that had been created by
	        MAKE-PROCESS. The life cycle of a foreign process is
	        certainly different from that of a lisp-created one: it
	        doesn't make sense to reset/preset/enable a foreign process,
	        and attempts to perform these operations should be
	        detected and treated as errors.</para>
	    </listitem>
      </itemizedlist>
    </sect2>
  </sect1>



  <sect1 id="Porting-Code-from-the-Old-Thread-Model">
    <title>Porting Code from the Old Thread Model</title>
    <para>Older versions of &CCL; used what are often called
      "user-mode threads", a less versatile threading model which does
      not require specific support from the operating system.  This
      section discusses how to port code which was written for that
      mode.</para>
    <para>It's hard to give step-by-step instructions; there are certainly
      a few things that one should look at carefully:</para>
    <itemizedlist>
      <listitem>
	    <para>It's wise to be suspicious of most uses
	      of WITHOUT-INTERRUPTS; there may be exceptions, but
	      WITHOUT-INTERRUPTS is often used as shorthand for
	      WITH-APPROPRIATE-LOCKING. Determining what type of locking
	      is appropriate and writing the code to implement it is
	      likely to be straightforward and simple most of the
	      time.</para>
	  </listitem>
      <listitem>
	    <para>I've only seen one case where a process's "run reasons"
	      were used to communicate information as well as to control
	      execution; I don't think that this is a common idiom, but may
	      be mistaken about that.
	    </para>
	  </listitem>
      <listitem>
	    <para>It's certainly possible that programs written
	      for cooperatively scheduled lisps that have run reliably for
	      a long time have done so by accident: resource-contention
	      issues tend to be timing-sensitive, and decoupling thread
	      scheduling from lisp program execution affects timing. I know
	      that there is or was code in both &CCL; and commercial MCL
	      that was written under the explicit assumption that certain
	      sequences of open-coded operations were uninterruptable; it's
	      certainly possible that the same assumptions have been made
	      (explicitly or otherwise) by application developers.</para>
	  </listitem>
    </itemizedlist>
  </sect1>

  <sect1 id="Background-Terminal-Input">
    <title>Background Terminal Input</title>

    <sect2 id="backgrount-ti-overview">
      <title>Overview</title>
	  <para>
	    Unless and until &CCL; provides alternatives (via window
	    streams, telnet streams, or some other mechanism) all lisp
	    processes share a common *TERMINAL-IO* stream (and therefore
	    share *DEBUG-IO*, *QUERY-IO*, and other standard and
	    internal interactive streams.)</para>
	  <para>It's anticipated that most lisp processes other than
	    the "Initial" process run mostly in the background. If a
	    background process writes to the output side of
	    *TERMINAL-IO*, that may be a little messy and a little
	    confusing to the user, but it shouldn't really be
	    catastrophic. All I/O to &CCL;'s buffered streams goes
	    thru a locking mechanism that prevents the worst kinds of
	    resource-contention problems.</para>
	  <para>Although the problems associated with terminal output
	    from multiple processes may be mostly cosmetic, the question
	    of which process receives input from the terminal is likely
	    to be a great deal more important. The stream locking
	    mechanisms can make a confusing situation even worse:
	    competing processes may "steal" terminal input from each
	    other unless locks are held longer than they otherwise need
	    to be, and locks can be held longer than they need to be (as
	    when a process is merely waiting for input to become
	    available on an underlying file descriptor).</para>
	  <para>Even if background processes rarely need to
	    intentionally read input from the terminal, they may still
	    need to do so in response to errors or other unanticipated
	    situations. There are tradeoffs involved in any solution to
	    this problem. The protocol described below allows background
	    processes which follow it to reliably prompt for and receive
	    terminal input. Background processes which attempt to
	    receive terminal input without following this protocol will
	    likely hang indefinitely while attempting to do so. That's
	    certainly a harsh tradeoff, but since attempts to read
	    terminal input without following this protocol only worked
	    some of the time anyway, it doesn't seem to be an
	    unreasonable one.</para>
	  <para>In the solution described here (and introduced in
	    &CCL; 0.9), the internal stream used to provide terminal
	    input is always locked by some process (the "owning"
	    process.) The initial process (the process that typically
	    runs the read-eval-print loop) owns that stream when it's
	    first created. By using the macro WITH-TERMINAL-INPUT,
	    background processes can temporarily obtain ownership of the
	    terminal and relinquish ownership to the previous owner when
	    they're done with it.</para>
	  <para>In &CCL;, BREAK, ERROR, CERROR, Y-OR-N-P,
	    YES-OR-NO-P, and CCL:GET-STRING- FROM-USER are all defined
	    in terms of WITH-TERMINAL-INPUT, as are the :TTY
	    user-interfaces to STEP and INSPECT.</para>
    </sect2>

    <sect2 id="background-terminal-example">
      <title>An example</title>

      <programlisting>
? Welcome to &CCL; Version (Beta: linux) 0.9!
?

? (process-run-function "sleeper" #'(lambda () (sleep 5) (break "broken")))
#&lt;PROCESS sleeper(1) [Enabled] #x3063B33E&gt;

?
;;
;; Process sleeper(1) needs access to terminal input.
;;
      </programlisting>

      <para>This example was run under ILISP; ILISP often gets confused if one
	    tries to enter input and "point" doesn't follow a prompt.
	    Entering a "simple" expression at this point gets it back in
	    synch; that's otherwise not relevant to this example.</para>

	  <programlisting>
()
NIL
? (:y 1)
;;
;; process sleeper(1) now controls terminal input
;;
> Break in process sleeper(1): broken
> While executing: #&lt;Anonymous Function #x3063B276&gt;
> Type :GO to continue, :POP to abort.
> If continued: Return from BREAK.
Type :? for other options.
1 &gt; :b
(30C38E30) : 0 "Anonymous Function #x3063B276" 52
(30C38E40) : 1 "Anonymous Function #x304984A6" 376
(30C38E90) : 2 "RUN-PROCESS-INITIAL-FORM" 340
(30C38EE0) : 3 "%RUN-STACK-GROUP-FUNCTION" 768
1 &gt; :pop
;;
;; control of terminal input restored to process Initial(0)
;;
?
      </programlisting>
    </sect2>

    <sect2 id="A-more-elaborate-example-">
      <title>A more elaborate example.</title>
	  <para>If a background process ("A") needs access to the terminal
	    input stream and that stream is owned by another background process
	    ("B"), process "A" announces that fact, then waits until
	    the initial process regains control.</para>

	  <programlisting>
? Welcome to &CCL; Version (Beta: linux) 0.9!
?

? (process-run-function "sleep-60" #'(lambda () (sleep 60) (break "Huh?")))
#&lt;PROCESS sleep-60(1) [Enabled] #x3063BF26&gt;

? (process-run-function "sleep-5" #'(lambda () (sleep 5) (break "quicker")))
#&lt;PROCESS sleep-5(2) [Enabled] #x3063D0A6&gt;

?       ;;
;; Process sleep-5(2) needs access to terminal input.
;;
()
NIL

? (:y 2)
;;
;; process sleep-5(2) now controls terminal input
;;
> Break in process sleep-5(2): quicker
> While executing: #x3063CFDE>
> Type :GO to continue, :POP to abort.
> If continued: Return from BREAK.
Type :? for other options.
1 >     ;; Process sleep-60(1) will need terminal access when
;; the initial process regains control of it.
;;
()
NIL
1 > :pop
;;
;; Process sleep-60(1) needs access to terminal input.
;;
;;
;; control of terminal input restored to process Initial(0)
;;

? (:y 1)
;;
;; process sleep-60(1) now controls terminal input
;;
> Break in process sleep-60(1): Huh?
> While executing: #x3063BE5E>
> Type :GO to continue, :POP to abort.
> If continued: Return from BREAK.
Type :? for other options.
1 > :pop
;;
;; control of terminal input restored to process Initial(0)
;;

?
      </programlisting>

    </sect2>

    <sect2 id="Summary">
	  <title>Summary</title>
	  <para>This scheme is certainly not bulletproof: imaginative
	    use of PROCESS-INTERRUPT and similar functions might be able
	    to defeat it and deadlock the lisp, and any scenario where
	    several background processes are clamoring for access to the
	    shared terminal input stream at the same time is likely to be
	    confusing and chaotic. (An alternate scheme, where the input
	    focus was magically granted to whatever thread the user was
	    thinking about, was considered and rejected due to technical
	    limitations.)</para>
	  <para>The longer-term fix would probably involve using network or
	    window-system streams to give each process unique instances of
	    *TERMINAL-IO*.</para>
      <para>Existing code that attempts to read from *TERMINAL-IO*
        from a background process will need to be changed to use
        WITH-TERMINAL-INPUT.  Since that code was probably not working
        reliably in previous versions of &CCL;, this requirement
        doesn't seem to be too onerous.</para>
      <para>Note that WITH-TERMINAL-INPUT both requests ownership of
        the terminal input stream and promises to restore that
        ownership to the initial process when it's done with it. An ad
        hoc use of READ or READ-CHAR doesn't make this promise; this
        is the rationale for the restriction on the :Y command.</para>
    </sect2>
  </sect1>

  <sect1 id="The-Threads-which-CCL-Uses-for-Its-Own-Purposes">
    <title>The Threads which &CCL; Uses for Its Own Purposes</title>
    <para>
      In the "tty world", &CCL; starts out with 2 lisp-level threads:</para>

    <programlisting>
? :proc
1 : -> listener     [Active]
0 :    Initial      [Active]
    </programlisting>

    <para>If you look at a running &CCL; with a debugging tool,
      such as GDB, or Apple's Thread Viewer.app, you'll see an
      additional kernel-level thread on Darwin; this is used by the
      Mach exception-handling mechanism.</para>
    <para>The initial thread, conveniently named "initial", is the
      one that was created by the operating system when it launched
      &CCL;.  It maps the heap image into memory, does some
      Lisp-level initialization, and, when the Cocoa IDE isn't being
      used, creates the thread "listener", which runs the top-level
      loop that reads input, evaluates it, and prints the
      result.</para>
    <para>After the listener thread is created, the initial thread
      does "housekeeping": it sits in a loop, sleeping most of the
      time and waking up occasionally to do "periodic tasks".  These
      tasks include forcing output on specified interactive streams,
      checking for and handling control-C interrupts, etc.  Currently,
      those tasks also include polling for the exit status of external
      processes and handling some kinds of I/O to and from those
      processes.</para>
    <para>In this environment, the initial thread does these
      "housekeeping" activities as necessary, until
      <literal>ccl:quit</literal> is called;
      <literal>quit</literal>ting interrupts the initial thread, which
      then ends all other threads in as orderly a fashion as possible
      and calls the C function <literal>#_exit</literal>.</para>
    <para>The short-term plan is to handle each external-process in
      a dedicated thread; the worst-case behavior of the current
      scheme can involve busy-waiting and excessive CPU utilization
      while waiting for an external process to terminate in some
      cases.</para>
    <para>The Cocoa features use more threads.  Adding a Cocoa
      listener creates two threads:</para>

    <programlisting>
      ? :proc
      3 : -> Listener     [Active]
      2 :    housekeeping  [Active]
      1 :    listener     [Active]
      0 :    Initial      [Active]
    </programlisting>

    <para>The Cocoa event loop has to run in the initial thread;
      when the event loop starts up, it creates a new thread to do the
      "housekeeping" tasks which the initial thread would do in the
      terminal-only mode.  The initial thread then becomes the one to
      receive all Cocoa events from the window server; it's the only
      thread which can.</para>
    <para>It also creates one "Listener" (capital-L) thread for each
      listener window, with a lifetime that lasts as long as the
      thread does.  So, if you open a second listener, you'll see five
      threads all together:</para>

    <programlisting>
      ? :proc
      4 : -> Listener-2   [Active]
      3 :    Listener     [Active]
      2 :    housekeeping  [Active]
      1 :    listener     [Active]
      0 :    Initial      [Active]
    </programlisting>

    <para>Unix signals, such as SIGINT (control-C), invoke a handler
      installed by the Lisp kernel.  Although the OS doesn't make any
      specific guarantee about which thread will receive the signal,
      in practice, it seems to be the initial thread.  The handler
      just sets a flag and returns; the housekeeping thread (which may
      be the initial thread, if Cocoa's not being used) will check for
      the flag and take whatever action is appropriate to the
      signal.</para>
    <para>In the case of SIGINT, the action is to enter a break
      loop, by calling on the thread being interrupted.  When there's
      more than one Lisp listener active, it's not always clear what
      thread that should be, since it really depends on the user's
      intentions, which there's no way to divine programmatically.  To
      make its best guess, the handler first checks whether the value
      of <literal>ccl:*interactive-abort-process*</literal> is a
      thread, and, if so, uses it.  If that fails, it chooses the
      thread which currently "owns" the default terminal input stream;
      see .</para>
    <para>In the bleeding-edge version of the Cocoa support which is
      based on Hemlock, an Emacs-like editor, each editor window has a
      dedicated thread associated with it.  When a keypress event
      comes in which affects that specific window the initial thread
      sends it to the window's dedicated thread.  The dedicated thread
      is responsible for trying to interpret keypresses as Hemlock
      commands, applying those commands to the active buffer; it
      repeats this in a loop, until the window closes.  The initial
      thread handles all other events, such as mouse clicks and
      drags.</para>
    <para>This thread-per-window scheme makes many things simpler,
      including the process of entering a "recursive command loop" in
      commands like "Incremental Search Forward", etc.  (It might be
      possible to handle all Hemlock commands in the Cocoa event
      thread, but these "recursive command loops" would have to
      maintain a lot of context/state information; threads are a
      straightforward way of maintaining that information.)</para>
    <para>Currently (August 2004), when a dedicated thread needs to
      alter the contents of the buffer or the selection, it does so by
      invoking methods in the initial thread, for synchronization
      purposes, but this is probably overkill and will likely be
      replaced by a more efficient scheme in the future.</para>
    <para>The per-window thread could probably take more
      responsibility for drawing and handling the screen than it
      currently does; -something- needs to be done to buffer screen
      updates a bit better in some cases: you don't need to see
      everything that happens during something like indentation; you
      do need to see the results...</para>
    <para>When Hemlock is being used, listener windows are editor
      windows, so in addition to each "Listener" thread, you should
      also see a thread which handles Hemlock command
      processing.</para>
    <para>The Cocoa runtime may make additional threads in certain
      special situations; these threads usually don't run lisp code,
      and rarely if ever run much of it.</para>
  </sect1>

  <sect1 id="Threads-Dictionary">
    <title>Threads Dictionary</title>
    <refentry id="f_all-processes">
	  <indexterm zone="f_all-processes">
	    <primary>all-processes</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>ALL-PROCESSES</refname>
	    <refpurpose>Obtain a fresh list of all known Lisp
	      threads.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis>
	      <function>all-processes</function> => result
	    </synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>a list of all lisp processes (threads)
		        known to &CCL;.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>
	  <refsect1>
	    <title>Description</title>

	    <para>Returns a list of all lisp processes (threads) known
	      to &CCL; as of
	      the precise instant it&#39;s called. It&#39;s safe to traverse
	      this list and to modify the cons cells that comprise that list
	      (it&#39;s freshly consed.) Since other threads can create and kill
	      threads at any time, there&#39;s generally no way to get an
	      &#34;accurate&#34; list of all threads, and (generally) no
	      sense in which such a list can be accurate.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="v_current-process"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_make-process">
	  <indexterm zone="f_make-process">
	    <primary>make-process</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>MAKE-PROCESS</refname>
	    <refpurpose>Creates and returns a new process.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis>
	      <function>make-process</function>
	      name &amp;key
	      persistent priority class stack-size vstack-size
	      tstack-size initial-bindings use-standard-initial-bindings
	      => process
	    </synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>name</term>
	        
	        <listitem>
		      <para>a string, used to identify the process.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>persistent</term>
	        
	        <listitem>
		      <para>if true, requests that information about the process
		        be retained by SAVE-APPLICATION so that an equivalent
		        process can be restarted when a saved image is run.  The
		        default is nil.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>priority</term>
	        
	        <listitem>
		      <para>ignored.  It
		        shouldn't be ignored of course, but there are
		        complications on some platforms.  The default is 0.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>class</term>
	        
	        <listitem>
		      <para>the class of process object to create;
		        should be a subclass of CCL:PROCESS.  The default is
		        CCL:PROCESS.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>stack-size</term>
	        
	        <listitem>
		      <para>the size, in bytes, of the newly-created process's
		        control stack; used for foreign function calls and to save
		        function return address context.  The default is
		        CCL:*DEFAULT-CONTROL-STACK-SIZE*.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>vstack-size</term>
	        
	        <listitem>
		      <para>the size, in bytes, of the newly-created process's
		        value stack; used for lisp function arguments, local
		        variables, and other stack-allocated lisp objects.
		        The default is CCL:*DEFAULT-VALUE-STACK-SIZE*.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>tstack-size</term>
	        
	        <listitem>
		      <para>the size, in bytes, of the newly-created process's
		        temp stack; used for the allocation of dynamic-extent
		        objects.  The default is CCL:*DEFAULT-TEMP-STACK-SIZE*.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>use-standard-initial-bindings</term>
	        
	        <listitem>
		      <para>when true, the global "standard initial
		        bindings" are put into effect in the new thread before. See
		        DEF-STANDARD-INITIAL-BINDING.  "standard" initial bindings
		        are put into effect before any bindings specified by
		        :initial-bindings are.  The default is t.

                       <emphasis role="strong">This option is deprecated: the correct
                      behavior of many &CCL; components depends on thread-local
                      bindings of many special variables being in effect.</emphasis></para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>initial-bindings</term>
	        
	        <listitem>
		      <para>an alist of (<varname>symbol</varname> .
		        <varname>valueform</varname>) pairs, which can be
		        used to initialize special variable bindings in the new
		        thread. Each <varname>valueform</varname> is used to
		        compute the value of a new binding of
		        <varname>symbol</varname> in the execution environment of
		        the newly-created thread.  The default is nil.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>process</term>
	        
	        <listitem>
		      <para>the newly-created process.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Creates and returns a new lisp process (thread) with the
	      specified attributes. <varname>process</varname> will not begin
	      execution immediately; it will need to be
	      <emphasis>preset</emphasis> (given
	      an initial function to run, as by
	      <xref linkend="f_process-preset"/>) and
	      <emphasis>enabled</emphasis>
	      (allowed to execute, as by <xref linkend="f_process-enable"/>)
	      before it&#39;s able to actually do anything.</para>

	    <para>If <varname>valueform</varname> is a function, it is
	      called, with no arguments, in the execution environment of the
	      newly-created thread; the primary value it returns is used for
	      the binding of the corresponding <varname>symbol</varname>.</para>

	    <para>Otherwise, <varname>valueform</varname> is evaluated in the
	      execution
	      environment of the newly-created thread, and the resulting value
	      is used.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-preset"/></member>
	      <member><xref linkend="f_process-enable"/></member>
	      <member><xref linkend="f_process-run-function"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-suspend">
	  <indexterm zone="f_process-suspend">
	    <primary>process-suspend</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-SUSPEND</refname>
	    <refpurpose>Suspends a specified process.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>
	  
	  <refsynopsisdiv>
	    <synopsis><function>process-suspend</function> process
	      => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread).</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>T if <varname>process</varname> had been runnable
		        and is now suspended; NIL otherwise.  That is, T if
		        <varname>process</varname>'s
		        <xref linkend="f_process-suspend-count"/>
		        transitioned from 0 to 1.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Suspends <varname>process</varname>, preventing it from
	      running, and stopping it if it was already running. This is a fairly
	      expensive operation, because it involves a few
	      calls to the OS.  It also risks creating deadlock if used
	      improperly, for instance, if the process being suspended owns a
	      lock or other resource which another process will wait for.</para>

	    <para>
	      Each
	      call to <function>process-suspend</function> must be reversed by
	      a matching call to <xref linkend="f_process-resume"/>
	      before <varname>process</varname> is able to run.  What
	      <function>process-suspend</function> actually does is increment
	      the <xref linkend="f_process-suspend-count"/> of
	      <varname>process</varname>.
	    </para>

	    <para>A process can't suspend itself, though this once
	    worked and this documentation claimed has claimed that it
	    did.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-resume"/></member>
	      <member><xref linkend="f_process-suspend-count"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>
	    <para><function>process-suspend</function> was previously called
	      <function>process-disable</function>.
	      <xref linkend="f_process-enable"/>
	      now names a function for which there is no
	      obvious inverse, so <function>process-disable</function>
	      is no longer
	      defined.</para>
	  </refsect1>
    </refentry>

    <refentry id="f_process-resume">
	  <indexterm zone="f_process-resume">
	    <primary>process-resume</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-RESUME</refname>
	    <refpurpose>Resumes a specified process which had previously
	      been suspended by process-suspend.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-resume</function> process
	      => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread).</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>T if <varname>process</varname> had been suspended
		        and is now runnable; NIL otherwise.  That is, T if
		        <varname>process</varname>'s
		        <xref linkend="f_process-suspend-count"/>
		        transitioned from  to 0.
		      </para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Undoes the effect of a previous call to
	      <xref linkend="f_process-suspend"/>; if
	      all such calls are undone, makes the process runnable. Has no
	      effect if the process is not suspended.  What
	      <function>process-resume</function> actually does is decrement
	      the <xref linkend="f_process-suspend-count"/> of
	      <varname>process</varname>, to a minimum of 0.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-suspend"/></member>
	      <member><xref linkend="f_process-suspend-count"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>

	    <para>
	      This was previously called PROCESS-ENABLE;
	      <xref linkend="f_process-enable"/> now does something slightly
	      different.
	    </para>
	  </refsect1>
    </refentry>

    <refentry id="f_process-suspend-count">
	  <indexterm zone="f_process-suspend-count">
	    <primary>process-suspend-count</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-SUSPEND-COUNT</refname>
	    <refpurpose>Returns the number of currently-pending suspensions
	      applicable to a given process.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis>
	      <function>process-suspend-count</function>
	      process => result
	    </synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread).</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>The number of "outstanding"
		        <xref linkend="f_process-suspend"/> calls on
		        <varname>process</varname>, or NIL if
		        <varname>process</varname> has expired.
		      </para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>An "outstanding" <xref linkend="f_process-suspend"/> call
	      is one which has not yet been reversed by a call to
	      <xref linkend="f_process-resume"/>.  A process expires when
	      its initial function returns, although it may later be
	      reset.</para>

	    <para>A process is <emphasis>runnable</emphasis> when it has a
	      <function>process-suspend-count</function> of 0, has been
	      preset as by <xref linkend="f_process-preset"/>, and has been
	      enabled as by <xref linkend="f_process-enable"/>.  Newly-created
	      processes have a <function>process-suspend-count</function> of
	      0.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-suspend"/></member>
	      <member><xref linkend="f_process-resume"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-preset">
	  <indexterm zone="f_process-preset">
	    <primary>process-preset</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-PRESET</refname>
	    <refpurpose>Sets the initial function and arguments of a specified
	      process.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-preset</function>
	      process function &rest; args
	      => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread).</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>function</term>
	        <listitem>
		      <para>a function, designated by itself or by a symbol
		        which names it.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>args</term>
	        <listitem>
		      <para>a list of values, appropriate as arguments to
		        <varname>function</varname>.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>undefined.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Typically used to initialize a newly-created or newly-reset
	      process, setting things up so that when <varname>process</varname>
	      becomes enabled, it will begin execution by
	      applying <varname>function</varname> to <varname>args</varname>.
	      <function>process-preset</function> does not enable
	      <varname>process</varname>,
	      although a process must be <function>process-preset</function>
	      before it can be enabled.  Processes are normally enabled by
	      <xref linkend="f_process-enable"/>.
	    </para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-process"/></member>
	      <member><xref linkend="f_process-enable"/></member>
	      <member><xref linkend="f_process-run-function"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-enable">
	  <indexterm zone="f_process-enable">
	    <primary>process-enable</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-ENABLE</refname>
	    <refpurpose>Begins executing the initial function of a specified
	      process.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-enable</function>
	      process &optional; timeout
	    </synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread).</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>timeout</term>
	        <listitem>
		      <para>a time interval in seconds.  May be any
		        non-negative real number the <function>floor</function> of
		        which fits in 32 bits.  The default is 1.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>undefined.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Tries to begin the execution of <varname>process</varname>.
	      An error is signaled if <varname>process</varname> has never
	      been <xref linkend="f_process-preset"/>.  Otherwise,
	      <varname>process</varname> invokes its initial function.
	    </para>
	    
	    <para><function>process-enable</function> attempts to
	      synchronize with <varname>process</varname>, which is presumed
	      to be reset or in the act of resetting itself.  If this attempt
	      is not successful within the time interval specified by
	      <varname>timeout</varname>, a continuable error is signaled,
	      which offers the opportunity to continue waiting.
	    </para>

	    <para>A process cannot meaningfully attempt to enable itself.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-process"/></member>
	      <member><xref linkend="f_process-preset"/></member>
	      <member><xref linkend="f_process-run-function"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>

	    <para>It would be nice to have more discussion of what it means
	      to synchronize with the process.</para>
	  </refsect1>
    </refentry>

    <refentry id="f_process-run-function">
	  <indexterm zone="f_process-run-function">
	    <primary>process-run-function</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-RUN-FUNCTION</refname>
	    <refpurpose>Creates a process, presets it, and enables it.
	    </refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-run-function</function>
	      process-specifier function &rest; args => process</synopsis>

	    <variablelist>
	      <varlistentry>
	        <term>process-specifier</term>
	        <listitem>
		      <para>
		        <varname>name</varname> | 
		        (&key; <varname>name</varname>
		        <varname>persistent</varname>
		        <varname>priority</varname>
		        <varname>class</varname>
		        <varname>stack-size</varname>
		        <varname>vstack-size</varname>
		        <varname>tstack-size</varname>)
		      </para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>name</term>
	        <listitem>
		      <para>a string, used to identify the process.
		        Passed to <function>make-process</function>.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>function</term>
	        <listitem>
		      <para>a function, designated by itself or by a symbol
		        which names it.  Passed to
		        <function>preset-process</function>.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>persistent</term>
	        
	        <listitem>
		      <para>a boolean, passed to <function>make-process</function>.
		      </para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>priority</term>
	        
	        <listitem>
		      <para>ignored.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>class</term>
	        
	        <listitem>
		      <para>a subclass of CCL:PROCESS.  Passed to
		        <function>make-process</function>.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>stack-size</term>
	        
	        <listitem>
		      <para>a size, in bytes.  Passed to
		        <function>make-process</function>.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>vstack-size</term>
	        
	        <listitem>
		      <para>a size, in bytes.  Passed to
		        <function>make-process</function>.</para>
	        </listitem>
	      </varlistentry>
	      
	      <varlistentry>
	        <term>tstack-size</term>
	        
	        <listitem>
		      <para>a size, in bytes.  Passed to
		        <function>make-process</function>.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>the newly-created process.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Creates a lisp process (thread) via
	      <xref linkend="f_make-process"/>,
	      presets it via <xref linkend="f_process-preset"/>, and
	      enables it via <xref linkend="f_process-enable"/>.  This means
	      that <varname>process</varname> will immediately begin to
	      execute.
	      <function>process-run-function</function> is
	      the simplest way to create and run a process.
	    </para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-process"/></member>
	      <member><xref linkend="f_process-preset"/></member>
	      <member><xref linkend="f_process-enable"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-interrupt">
	  <indexterm zone="f_process-interrupt">
	    <primary>process-interrupt</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-INTERRUPT</refname>
	    <refpurpose>Arranges for the target process to invoke a
	      specified function at some point in the near future, and then
	      return to what it was doing.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-interrupt</function>
	      process function &rest; args => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread).</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>function</term>
	        <listitem>
		      <para>a function.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>args</term>
	        <listitem>
		      <para>a list of values, appropriate as arguments to
		        <varname>function</varname>.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>the result of applying <varname>function</varname>
		        to <varname>args</varname> if <varname>process</varname>
		        is the <function>current-process</function>, otherwise
		        NIL.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Arranges for <varname>process</varname>
	      to apply <varname>function</varname> to <varname>args</varname> at
	      some point in the near future (interrupting whatever
	      <varname>process</varname>
	      was doing.) If <varname>function</varname> returns normally,
	      <varname>process</varname> resumes
	      execution at the point at which it was interrupted.</para>

	    <para><varname>process</varname> must be in an enabled state in
	      order to respond
	      to a <function>process-interrupt</function> request.  It's
	      perfectly legal for a process to call
	      <function>process-interrupt</function> on itself.</para>

	    <para><function>process-interrupt</function>
	      uses asynchronous POSIX signals to interrupt threads. If the
	      thread being interrupted is executing lisp code, it can
	      respond to the interrupt almost immediately (as soon as it
	      has finished pseudo-atomic operations like consing and
	      stack-frame initialization.)</para>

	    <para>If the interrupted thread is
	      blocking in a system call, that system call is aborted by
	      the signal and the interrupt is handled on return.
	    </para>

	    <para>It is
	      still difficult to reliably interrupt arbitrary foreign code
	      (that may be stateful or otherwise non-reentrant); the
	      interrupt request is handled when such foreign code returns
	      to or enters lisp.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="m_without-interrupts"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>

	    <para>It would probably be better for <varname>result</varname>
	      to always be NIL, since the present behavior is inconsistent.
	    </para>

	    <para>
	      <function>Process-interrupt</function> works by sending signals
	      between threads, via the C function
	      <function>#_pthread_signal</function>.  It could be argued
	      that it should be done in one of several possible other ways
	      under
	      Darwin, to make it practical to asynchronously interrupt
	      things which make heavy use of the Mach nanokernel.
	    </para>
	  </refsect1>
    </refentry>

    <refentry id="v_current-process">
	  <indexterm zone="v_current-process">
	    <primary>*current-process*</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>*CURRENT-PROCESS*</refname>
	    <refpurpose>Bound in each process, to that process
	      itself.</refpurpose>
	    <refclass>Variable</refclass>
	  </refnamediv>

	  <refsect1>
	    <title>Value Type</title>

	    <para>A lisp process (thread).</para>
	  </refsect1>

	  <refsect1>
	    <title>Initial Value</title>
	    
	    <para>Bound separately in each process, to that process itself.
	    </para>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Used when lisp code needs to find out what process it is
	      executing in.  Shouldn't be set by user code.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_all-processes"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-reset">
	  <indexterm zone="f_process-reset">
	    <primary>process-reset</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-RESET</refname>
	    <refpurpose>Causes a specified process to cleanly exit from
	      any ongoing computation.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-reset</function>
	      process &optional; kill-option => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread).</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>kill-option</term>
	        <listitem>
		      <para>an internal argument, must be nil.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>undefined.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Causes <varname>process</varname> to cleanly exit
	      from any ongoing computation and enter a state where it can be
	      <xref linkend="f_process-preset"/>. This
	      is implemented by signaling a condition of type PROCESS-RESET;
	      user-defined condition handlers should generally refrain from
	      attempting to handle conditions of this type.</para>

            <para>The <varname>kill-option</varname> argument is for internal
            use only and should not be specified by user code</para>

	    <para>A process can meaningfully reset itself.</para>

	    <para>There is in general no way to know precisely when
	      <varname>process</varname>
	      has completed the act of resetting or killing itself; a process
	      which has either entered the limbo of the reset state or exited
	      has few ways of communicating either fact.
	      <xref linkend="f_process-enable"/>
	      can reliably determine when a process has entered
	      the "limbo of the reset state", but can't predict how long the
	      clean exit from ongoing computation might take: that depends on
	      the behavior of <function>unwind-protect</function> cleanup
	      forms, and of the OS scheduler.</para>

	    <para>Resetting a process other than
	      <xref linkend="v_current-process"/> involves the
	      use of <xref linkend="f_process-interrupt"/>.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-kill"/></member>
	      <member><xref linkend="f_process-abort"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-reset-and-enable">
	  <indexterm zone="f_process-reset-and-enable">
	    <primary>process-reset-and-enable</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-RESET-AND-ENABLE</refname>
	    <refpurpose>Reset and enable the specified process, which
	    may not be the current process.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-reset-and-enable</function>
	      process => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread), which
		      may not be the current process.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>undefined.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>
	      Equivalent to calling (process-reset process) and
	      (process-enable process).
	    </para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-reset"/></member>
	      <member><xref linkend="f_process-enable"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-kill">
	  <indexterm zone="f_process-kill">
	    <primary>process-kill</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-KILL</refname>
	    <refpurpose>Causes a specified process to cleanly exit from any
	      ongoing computation, and then exit.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-kill</function> process
	      => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread).</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>undefined.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>
	      Causes <varname>process</varname> to cleanly exit
	      from any ongoing computation, and then exit.
	    </para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-reset"/></member>
	      <member><xref linkend="f_process-abort"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-abort">
	  <indexterm zone="f_process-abort">
	    <primary>process-abort</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-ABORT</refname>
	    <refpurpose>Causes a specified process to process an abort
	      condition, as if it had invoked
	      <function>abort</function>.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-abort</function> process
	      &optional; condition
	      => NIL</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread).</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>condition</term>
	        <listitem>
		      <para>a lisp condition.  The default is NIL.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Entirely equivalent to calling
	      (<xref linkend="f_process-interrupt"/> <varname>process</varname>
	      (<function>lambda</function> ()
	      (<function>abort</function> <varname>condition</varname>))).
	      Causes <varname>process</varname> to transfer control to the
	      applicable handler or restart for <function>abort</function>.</para>

	    <para>If <varname>condition</varname> is non-NIL,
	      <function>process-abort</function> does not consider any
	      handlers which are explicitly bound to conditions other than
	      <varname>condition</varname>.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-reset"/></member>
	      <member><xref linkend="f_process-kill"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="v_ticks-per-second">
	  <indexterm zone="v_ticks-per-second">
	    <primary>*ticks-per-second*</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>*TICKS-PER-SECOND*</refname>
	    <refpurpose>Bound to the clock resolution of the OS
	      scheduler.</refpurpose>
	    <refclass>Variable</refclass>
	  </refnamediv>

	  <refsect1>
	    <title>Value Type</title>

	    <para>A positive integer.</para>
	  </refsect1>

	  <refsect1>
	    <title>Initial Value</title>
	    
	    <para>The clock resolution of the OS scheduler.  Currently,
	      both LinuxPPC and DarwinPPC yield an initial value of 100.
	    </para>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>This value is ordinarily of marginal interest at best,
	      but, for backward compatibility, some functions accept timeout
	      values expressed in "ticks".  This value gives the number of
	      ticks per second.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-wait-with-timeout"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-whostate">
	  <indexterm zone="f_process-whostate">
	    <primary>process-whostate</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-WHOSTATE</refname>
	    <refpurpose>Returns a string which describes the status of
	      a specified process.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-whostate</function> process
	      => whostate</synopsis>
	    <variablelist>
	      <varlistentry>
	        <term>process</term>
	        <listitem>
		      <para>a lisp process (thread).</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>whostate</term>
	        <listitem>
		      <para>a string which describes the "state" of
		        <varname>process</varname>.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Description</title>

	    <para>This information is primarily for the benefit of
	      debugging tools.  <varname>whostate</varname> is a terse report
	      on what <varname>process</varname> is doing, or not doing,
	      and why.</para>

	    <para>If the process is currently waiting in a call to
	      <xref linkend="f_process-wait"/> or
	      <xref linkend="f_process-wait-with-timeout"/>, its
	      <function>process-whostate</function> will be the value
	      which was passed to that function as <varname>whostate</varname>.
	    </para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-wait"/></member>
	      <member><xref linkend="f_process-wait-with-timeout"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>

	    <para>This should arguably be SETFable, but doesn't seem to
	      ever have been.</para>
	  </refsect1>
    </refentry>

    <refentry id="f_process-allow-schedule">
	  <indexterm zone="f_process-allow-schedule">
	    <primary>process-allow-schedule</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-ALLOW-SCHEDULE</refname>
	    <refpurpose>Used for cooperative multitasking; probably never
	      necessary.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-allow-schedule</function></synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Description</title>

	    <para>Advises the OS scheduler that the current thread has nothing
	      useful to do and that it should try to find some other thread to
	      schedule in its place. There's almost always a better
	      alternative, such as waiting for some specific event to
	      occur.  For example, you could use a lock or semaphore.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>

	    <para>This is a holdover from the days of cooperative
	      multitasking.  All modern general-purpose operating systems use
	      preemptive multitasking.</para>
	  </refsect1>
    </refentry>

    <refentry id="f_process-wait">
	  <indexterm zone="f_process-wait">
	    <primary>process-wait</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-WAIT</refname>
	    <refpurpose>Causes the current lisp process (thread) to wait for
	      a given
	      predicate to return true.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-wait</function>
	      whostate function &rest; args => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>whostate</term>

	        <listitem>
		      <para>a string, which will be the value of
		        <xref linkend="f_process-whostate"/>
		        while the process is waiting.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>function</term>
	        <listitem>
		      <para>a function, designated by itself or by a symbol
		        which names it.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>args</term>
	        <listitem>
		      <para>a list of values, appropriate as arguments to
		        <varname>function</varname>.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>NIL.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Causes the current lisp process (thread) to repeatedly
	      apply <varname>function</varname> to
	      <varname>args</varname> until the call returns a true result, then
	      returns NIL. After
	      each failed call, yields the CPU as if by
	      <xref linkend="f_process-allow-schedule"/>.</para>
	    
	    <para>
	      As with <xref linkend="f_process-allow-schedule"/>, it's almost
	      always more efficient to wait for some
	      specific event to occur; this isn't exactly busy-waiting, but
	      the OS scheduler can do a better job of scheduling if it's given
	      the relevant information.  For example, you could use a lock
	      or semaphore.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-whostate"/></member>
	      <member><xref linkend="f_process-wait-with-timeout"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-wait-with-timeout">
	  <indexterm zone="f_process-wait-with-timeout">
	    <primary>process-wait-with-timeout</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-WAIT-WITH-TIMEOUT</refname>
	    <refpurpose>Causes the current thread to wait for a given
	      predicate to return true, or for a timeout to expire.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-wait-with-timeout</function>
	      whostate ticks function args => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>whostate</term>
	        <listitem>
		      <para>a string, which will be the value of
		        <xref linkend="f_process-whostate"/>
		        while the process is waiting.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>ticks</term>
	        <listitem>
		      <para>either a positive integer expressing a duration
		        in "ticks" (see <xref linkend="v_ticks-per-second"/>),
		        or NIL.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>function</term>
	        <listitem>
		      <para>a function, designated by itself or by a symbol
		        which names it.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>args</term>
	        <listitem>
		      <para>a list of values, appropriate as arguments to
		        <varname>function</varname>.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>T if <function>process-wait-with-timeout</function>
		        returned because its <varname>function</varname> returned
		        true, or NIL if it returned because the duration
		        <varname>ticks</varname> has been exceeded.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>If <varname>ticks</varname> is NIL, behaves exactly like
	      <xref linkend="f_process-wait"/>, except for returning T.
	      Otherwise, <varname>function</varname> will be tested repeatedly,
	      in the same
	      kind of test/yield loop as in <xref linkend="f_process-wait"/>
	      until either <varname>function</varname> returns true,
	      or the duration <varname>ticks</varname> has been exceeded.
	    </para>

	    <para> Having already read the descriptions of
	      <xref linkend="f_process-allow-schedule"/> and
	      <xref linkend="f_process-wait"/>, the
	      astute reader has no doubt anticipated the observation that
	      better alternatives should be used whenever possible.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="v_ticks-per-second"/></member>
	      <member><xref linkend="f_process-whostate"/></member>
	      <member><xref linkend="f_process-wait"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="m_without-interrupts">
	  <indexterm zone="m_without-interrupts">
	    <primary>without-interrupts</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>WITHOUT-INTERRUPTS</refname>
	    <refpurpose>Evaluates its body in an environment in which
	      process-interrupt requests are deferred.</refpurpose>
	    <refclass>Macro</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>without-interrupts</function>
	      &body; body => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>body</term>
	        <listitem>
		      <para>an implicit progn.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>the primary value returned by
		        <varname>body</varname>.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Executes <varname>body</varname>
	      in an environment in which <xref linkend="f_process-interrupt"/>
	      requests are
	      deferred. As noted in the description of
	      <xref linkend="f_process-interrupt"/>, this has nothing to do
	      with the
	      scheduling of other threads; it may be necessary to inhibit
	      <xref linkend="f_process-interrupt"/> handling when
	      (for instance) modifying some data
	      structure (for which the current thread holds an appropriate lock)
	      in some manner that&#39;s not reentrant.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_process-interrupt"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="m_with-interrupts-enabled">
	  <indexterm zone="m_with-interrupts-enabled">
	    <primary>with-interrupts-enabled</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>WITH-INTERRUPTS-ENABLED</refname>
	    <refpurpose>Evaluates its body in an environment in which
	      process-interrupt requests have immediate effect.</refpurpose>
	    <refclass>Macro</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>with-interrupts-enabled</function>
	      &body; body => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>body</term>
	        <listitem>
		      <para>an implicit progn.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>the primary value returned by
		        <varname>body</varname>.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Executes <varname>body</varname>
	      in an environment in which <xref linkend="f_process-interrupt"/>
	      requests have immediate effect.
	    </para>
	  </refsect1>
    </refentry>

    <refentry id="f_make-lock">
	  <indexterm zone="f_make-lock">
	    <primary>make-lock</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>MAKE-LOCK</refname>
	    <refpurpose>Creates and returns a lock object, which can
	      be used for synchronization between threads.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>make-lock</function> &optional;
	      name => lock</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>name</term>
	        <listitem>
		      <para>any lisp object; saved as part of
		        <varname>lock</varname>.  Typically a string or symbol
		        which may appear in the <xref linkend="f_process-whostate"/>s
		        of threads which are waiting for <varname>lock</varname>.
		      </para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>lock</term>
	        <listitem>
		      <para>a newly-allocated object of type CCL:LOCK.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Creates and returns a lock object, which can
	      be used to synchronize access to some shared resource.
	      <varname>lock</varname> is
	      initially in a &#34;free&#34; state; a lock can also be
	      &#34;owned&#34; by a
	      thread.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="m_with-lock-grabbed"/></member>
	      <member><xref linkend="f_grab-lock"/></member>
	      <member><xref linkend="f_release-lock"/></member>
	      <member><xref linkend="f_try-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="m_with-lock-grabbed">
	  <indexterm zone="m_with-lock-grabbed">
	    <primary>with-lock-grabbed</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>WITH-LOCK-GRABBED</refname>
	    <refpurpose>Waits until a given lock can be obtained, then
	      evaluates its body with the lock held.</refpurpose>
	    <refclass>Macro</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>with-lock-grabbed</function>
	      (lock) &body; body</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>lock</term>
	        <listitem>
		      <para>an object of type CCL:LOCK.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>body</term>
	        <listitem>
		      <para>an implicit progn.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>the primary value returned by
		        <varname>body</varname>.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Waits until <varname>lock</varname> is either free or
	      owned by the calling
	      thread, then executes <varname>body</varname> with the
	      lock owned by the calling thread. If <varname>lock</varname>
	      was free when <function>with-lock-grabbed</function> was called,
	      it is restored to a free state after <varname>body</varname>
	      is executed.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_grab-lock"/></member>
	      <member><xref linkend="f_release-lock"/></member>
	      <member><xref linkend="f_try-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_grab-lock">
	  <indexterm zone="f_grab-lock">
	    <primary>grab-lock</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>GRAB-LOCK</refname>
	    <refpurpose>Waits until a given lock can be obtained, then
	      obtains it.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>grab-lock</function> lock</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>lock</term>
	        <listitem>
		      <para>an object of type CCL:LOCK.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Blocks until <varname>lock</varname> is owned by the
	      calling thread.</para>

	    <para>The macro <xref linkend="m_with-lock-grabbed"/>
	      <emphasis>could</emphasis> be defined in
	      terms of <function>grab-lock</function> and
	      <xref linkend="f_release-lock"/>, but it is actually
	      implemented at a slightly lower level.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="m_with-lock-grabbed"/></member>
	      <member><xref linkend="f_release-lock"/></member>
	      <member><xref linkend="f_try-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_release-lock">
	  <indexterm zone="f_release-lock">
	    <primary>release-lock</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>RELEASE-LOCK</refname>
	    <refpurpose>Relinquishes ownership of a given lock.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>release-lock</function> lock</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>lock</term>
	        <listitem>
		      <para>an object of type CCL:LOCK.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Signals an error of type CCL:LOCK-NOT-OWNER if
	      <varname>lock</varname>
	      is not already owned by the calling thread; otherwise, undoes the
	      effect of one previous 
	      <xref linkend="f_grab-lock"/>.  If this means that
	      <function>release-lock</function> has now been called on
	      <varname>lock</varname> the same number of times as
	      <xref linkend="f_grab-lock"/> has, <varname>lock</varname>
	      becomes free.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="m_with-lock-grabbed"/></member>
	      <member><xref linkend="f_grab-lock"/></member>
	      <member><xref linkend="f_try-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_try-lock">
	  <indexterm zone="f_try-lock">
	    <primary>try-lock</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>TRY-LOCK</refname>
	    <refpurpose>Obtains the given lock, but only if it is not
	      necessary to wait for it.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>try-lock</function> lock => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>lock</term>
	        <listitem>
		      <para>an object of type CCL:LOCK.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>T if <varname>lock</varname> has been obtained,
		        or NIL if it has not.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Tests whether <varname>lock</varname>
	      can be obtained without blocking - that is, either
	      <varname>lock</varname> is already free, or it is already owned
	      by <xref linkend="v_current-process"/>.  If it can,
	      causes it to
	      be owned by the calling lisp process (thread) and returns T.
	      Otherwise, the lock
	      is already owned by another thread and cannot be obtained without
	      blocking; NIL is returned in this case.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="m_with-lock-grabbed"/></member>
	      <member><xref linkend="f_grab-lock"/></member>
	      <member><xref linkend="f_release-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_make-read-write-lock">
	  <indexterm zone="f_make-read-write-lock">
	    <primary>make-read-write-lock</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>MAKE-READ-WRITE-LOCK</refname>
	    <refpurpose>Creates and returns a read-write lock, which can
	      be used for synchronization between threads.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>make-read-write-lock</function>
	      => read-write-lock</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>read-write-lock</term>
	        <listitem>
		      <para>a newly-allocated object of type
		        CCL:READ-WRITE-LOCK.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Creates and returns an object of type CCL::READ-WRITE-LOCK.
	      A read-write lock may, at any given time, belong to any number
	      of lisp processes (threads) which act as "readers"; or, it may
	      belong to at most one process which acts as a "writer".  A
	      read-write lock may never be held by a reader at the same time as
	      a writer.  Initially, <varname>read-write-lock</varname> has
	      no readers and no writers.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="m_with-read-lock"/></member>
	      <member><xref linkend="m_with-write-lock"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>

	    <para>There probably should be some way to
	      atomically &#34;promote&#34; a reader, making it a writer without
	      releasing the lock, which could otherwise cause delay.</para>
	  </refsect1>
    </refentry>

    <refentry id="m_with-read-lock">
	  <indexterm zone="m_with-read-lock">
	    <primary>with-read-lock</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>WITH-READ-LOCK</refname>
	    <refpurpose>Waits until a given lock is available for
	      read-only access, then evaluates its body with the lock
	      held.</refpurpose>
	    <refclass>Macro</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>with-read-lock</function>
	      (read-write-lock) &body; body => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>read-write-lock</term>
	        <listitem>
		      <para>an object of type
		        CCL:READ-WRITE-LOCK.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>body</term>
	        <listitem>
		      <para>an implicit progn.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>the primary value returned by
		        <varname>body</varname>.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Waits until <varname>read-write-lock</varname> has no
	      writer,
	      ensures that <xref linkend="v_current-process"/> is a
	      reader of it, then executes <varname>body</varname>.
	    </para>

	    <para>After executing <varname>body</varname>, if
	      <xref linkend="v_current-process"/> was not a reader of
	      <varname>read-write-lock</varname> before
	      <function>with-read-lock</function> was called, the lock is
	      released.  If it was already a reader, it remains one.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="m_with-write-lock"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="m_with-write-lock">
	  <indexterm zone="m_with-write-lock">
	    <primary>with-write-lock</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>WITH-WRITE-LOCK</refname>
	    <refpurpose>Waits until the given lock is available for write
	      access, then executes its body with the lock held.</refpurpose>
	    <refclass>Macro</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>with-write-lock</function>
	      (read-write-lock) &body; body</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>read-write-lock</term>
	        <listitem>
		      <para>an object of type
		        CCL:READ-WRITE-LOCK.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>body</term>
	        <listitem>
		      <para>an implicit progn.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>the primary value returned by
		        <varname>body</varname>.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Waits until <varname>read-write-lock</varname> has no
	      readers and no writer other than <xref linkend="v_current-process"/>,
	      then ensures that <xref linkend="v_current-process"/> is the
	      writer of it.  With the lock held, executes <varname>body</varname>.
	    </para>

	    <para>After executing <varname>body</varname>, if
	      <xref linkend="v_current-process"/> was not the writer of
	      <varname>read-write-lock</varname> before
	      <function>with-write-lock</function> was called, the lock is
	      released.  If it was already the writer, it remains the
	      writer.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="m_with-read-lock"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_make-semaphore">
	  <indexterm zone="f_make-semaphore">
	    <primary>make-semaphore</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>MAKE-SEMAPHORE</refname>
	    <refpurpose>Creates and returns a semaphore, which can be used
	      for synchronization between threads.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>make-semaphore</function>
	      => semaphore</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>semaphore</term>
	        <listitem>
		      <para>a newly-allocated object of type CCL:SEMAPHORE.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Creates and returns an object of type CCL:SEMAPHORE.
	      A semaphore has an associated "count" which may be incremented
	      and decremented atomically; incrementing it represents sending
	      a signal, and decrementing it represents handling that signal.
	      <varname>semaphore</varname> has an initial count of 0.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_signal-semaphore"/></member>
	      <member><xref linkend="f_wait-on-semaphore"/></member>
	      <member><xref linkend="f_timed-wait-on-semaphore"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_signal-semaphore">
	  <indexterm zone="f_signal-semaphore">
	    <primary>signal-semaphore</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>SIGNAL-SEMAPHORE</refname>
	    <refpurpose>Atomically increments the count of a given
	      semaphore.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>signal-semaphore</function>
	      semaphore => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>semaphore</term>
	        <listitem>
		      <para>an object of type CCL:SEMAPHORE.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>an integer representing an error identifier
		        which was returned by the underlying OS call.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Atomically increments <varname>semaphore</varname>'s
	      "count" by 1; this
	      may enable a waiting thread to resume execution.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_wait-on-semaphore"/></member>
	      <member><xref linkend="f_timed-wait-on-semaphore"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>

	    <para><varname>result</varname> should probably be interpreted
	      and acted on by <function>signal-semaphore</function>, because
	      it is not likely to be meaningful to a lisp program, and the
	      most common cause of failure is a type error.</para>
	  </refsect1>
    </refentry>

    <refentry id="f_wait-on-semaphore">
	  <indexterm zone="f_wait-on-semaphore">
	    <primary>wait-on-semaphore</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>WAIT-ON-SEMAPHORE</refname>
	    <refpurpose>Waits until the given semaphore has a positive
	      count which can be atomically decremented.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>wait-on-semaphore</function>
	      semaphore => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>semaphore</term>
	        <listitem>
		      <para>an object of type CCL:SEMAPHORE.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>an integer representing an error identifier
		        which was returned by the underlying OS call.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Waits until <varname>semaphore</varname>
	      has a positive count that can be
	      atomically decremented; this will succeed exactly once for each
	      corresponding call to SIGNAL-SEMAPHORE.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_signal-semaphore"/></member>
	      <member><xref linkend="f_timed-wait-on-semaphore"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>

	    <para><varname>result</varname> should probably be interpreted
	      and acted on by <function>wait-on-semaphore</function>, because
	      it is not likely to be meaningful to a lisp program, and the
	      most common cause of failure is a type error.</para>
	  </refsect1>
    </refentry>

    <refentry id="f_timed-wait-on-semaphore">
	  <indexterm zone="f_timed-wait-on-semaphore">
	    <primary>timed-wait-on-semaphore</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>TIMED-WAIT-ON-SEMAPHORE</refname>
	    <refpurpose>Waits until the given semaphore has a positive
	      count which can be atomically decremented, or until a timeout
	      expires.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>timed-wait-on-semaphore</function>
	      semaphore timeout => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>semaphore</term>
	        <listitem>
		      <para>An object of type CCL:SEMAPHORE.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>timeout</term>
	        <listitem>
		      <para>a time interval in seconds.  May be any
		        non-negative real number the <function>floor</function> of
		        which fits in 32 bits.  The default is 1.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>T if <function>timed-wait-on-semaphore</function>
		        returned because it was able to decrement the count of
		        <varname>semaphore</varname>; NIL if it returned because
		        the duration <varname>timeout</varname> has been
		        exceeded.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Waits until <varname>semaphore</varname>
	      has a positive count that can be
	      atomically decremented, or until the duration
	      <varname>timeout</varname> has
	      elapsed.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_wait-on-semaphore"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_process-input-wait">
	  <indexterm zone="f_process-input-wait">
	    <primary>process-input-wait</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-INPUT-WAIT</refname>
	    <refpurpose>Waits until input is available on a given
	      file-descriptor.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-input-wait</function>
	      fd &optional; timeout</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>fd</term>
	        <listitem>
		      <para>a file descriptor, which is a non-negative integer
		        used by the OS to refer to an open file, socket, or similar
		        I/O connection.  See <xref linkend="f_stream-device"/>.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>timeout</term>
	        <listitem>
		      <para>either NIL or a time interval in milliseconds.  Must be a non-negative integer.  The default is NIL.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Wait until input is available on <varname>fd</varname>.
	      This uses the <function>select()</function> system call, and is
	      generally a fairly
	      efficient way of blocking while waiting for input. More
	      accurately, <function>process-input-wait</function>
	      waits until it&#39;s possible to read
	      from fd without blocking, or until <varname>timeout</varname>, if
	      it is not NIL, has been exceeded.</para>

	    <para>
	      Note that it&#39;s possible to read without blocking if
	      the file is at its end - although, of course, the read will
	      return zero bytes.</para>
	  </refsect1>
	  
	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>

	    <para>
	      <function>process-input-wait</function> has a timeout parameter,
	      and
	      <xref linkend="f_process-output-wait"/> does not.  This
	      inconsistency should probably be corrected.
	    </para>
	  </refsect1>
    </refentry>

    <refentry id="f_process-output-wait">
	  <indexterm zone="f_process-output-wait">
	    <primary>process-output-wait</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>PROCESS-OUTPUT-WAIT</refname>
	    <refpurpose>Waits until output is possible on a given file
	      descriptor.</refpurpose>
	    <refclass>Function</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>process-output-wait</function>
	      fd  &optional; timeout</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>fd</term>
	        <listitem>
		      <para>a file descriptor, which is a non-negative integer
		        used by the OS to refer to an open file, socket, or similar
		        I/O connection.  See <xref linkend="f_stream-device"/>.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>timeout</term>
	        <listitem>
		      <para>either NIL or a time interval in milliseconds.  Must be a non-negative integer.  The default is NIL.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Wait until output is possible on <varname>fd</varname> or until <varname>timeout</varname>, if
	      it is not NIL, has been exceeded.
	      This uses the <function>select()</function> system call, and is
	      generally a fairly
	      efficient way of blocking while waiting to output.</para>

	    <para>If <function>process-output-wait</function> is called on
	      a network socket which has not yet established a connection, it
	      will wait until the connection is established.  This is an
	      important use, often overlooked.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="m_with-terminal-input"/></member>
	    </simplelist>
	  </refsect1>

	  <refsect1>
	    <title>Notes</title>

	    <para>
	      <xref linkend="f_process-input-wait"/> has a timeout parameter,
	      and
	      <function>process-output-wait</function> does not.  This
	      inconsistency should probably be corrected.
	    </para>
	  </refsect1>
    </refentry>

    <refentry id="m_with-terminal-input">
	  <indexterm zone="m_with-terminal-input">
	    <primary>with-terminal-input</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>WITH-TERMINAL-INPUT</refname>
	    <refpurpose>Executes its body in an environment with exclusive
	      read access to the terminal.</refpurpose>
	    <refclass>Macro</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis><function>with-terminal-input</function>
	      &body; body => result</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>
	    
	    <variablelist>
	      <varlistentry>
	        <term>body</term>
	        <listitem>
		      <para>an implicit progn.</para>
	        </listitem>
	      </varlistentry>
	      <varlistentry>
	        <term>result</term>
	        <listitem>
		      <para>the primary value returned by
		        <varname>body</varname>.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Requests exclusive read access to the standard terminal
	      stream, <varname>*terminal-io*</varname>.  Executes
	      <varname>body</varname> in an environment with that access.
	    </para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref
	                 linkend="v_request-terminal-input-via-break"/></member>
	      <member><xref linkend="cmd_y"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="v_request-terminal-input-via-break">
	  <indexterm zone="v_request-terminal-input-via-break">
	    <primary>request-terminal-input-via-break</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>*REQUEST-TERMINAL-INPUT-VIA-BREAK*</refname>
	    <refpurpose>Controls how attempts to obtain ownership of
	      terminal input are made.</refpurpose>
	    <refclass>Variable</refclass>
	  </refnamediv>

	  <refsect1>
	    <title>Value Type</title>

	    <para>A boolean.</para>
	  </refsect1>

	  <refsect1>
	    <title>Initial Value</title>
	    
	    <para>NIL.</para>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>Controls how attempts to obtain ownership of terminal input
	      are made. When NIL, a message is printed on *TERMINAL-IO*;
	      it's expected that the user will later yield
	      control of the terminal via the :Y toplevel command. When T, a
	      BREAK condition is signaled in the owning process; continuing from
	      the break loop will yield the terminal to the requesting process
	      (unless the :Y command was already used to do so in the break
	      loop.)</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="m_with-terminal-input"/></member>
	      <member><xref linkend="cmd_y"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="cmd_y">
	  <indexterm zone="cmd_y">
	    <primary>:y</primary>
	  </indexterm>

	  <refnamediv>
	    <refname>:Y</refname>
	    <refpurpose>Yields control of terminal input to a specified
	      lisp process (thread).</refpurpose>
	    <refclass>Toplevel Command</refclass>
	  </refnamediv>

	  <refsynopsisdiv>
	    <synopsis>(<function>:y</function> p)</synopsis>
	  </refsynopsisdiv>

	  <refsect1>
	    <title>Arguments and Values</title>

	    <variablelist>
	      <varlistentry>
	        <term>p</term>
	        <listitem>
		      <para>a lisp process (thread), designated either by
		        an integer which matches its
		        <function>process-serial-number</function>,
		        or by a string which is <function>equal</function> to
		        its <function>process-name</function>.</para>
	        </listitem>
	      </varlistentry>
	    </variablelist>
	  </refsect1>

	  <refsect1>
	    <title>Description</title>

	    <para>:Y is a toplevel command, not a function.  As such, it
	      can only be used interactively, and only from the initial
	      process.</para>

	    <para>The command yields control of terminal input to the
	      process <varname>p</varname>, which must have used
	      <xref linkend="m_with-terminal-input"/> to request access to the
	      terminal input stream.</para>
	  </refsect1>

	  <refsect1>
	    <title>See Also</title>
	    
	    <simplelist type="inline">
	      <member><xref linkend="m_with-terminal-input"/></member>
	      <member><xref
	                 linkend="v_request-terminal-input-via-break"/></member>
	      <member><xref linkend="f_make-lock"/></member>
	      <member><xref linkend="f_make-read-write-lock"/></member>
	      <member><xref linkend="f_make-semaphore"/></member>
	      <member><xref linkend="f_process-input-wait"/></member>
	      <member><xref linkend="f_process-output-wait"/></member>
	    </simplelist>
	  </refsect1>
    </refentry>

    <refentry id="f_join-process">
      <indexterm zone="f_join-process">
	<primary>join-process</primary>
      </indexterm>

      <refnamediv>
	<refname>JOIN-PROCESS</refname>
	<refpurpose>Waits for a specified process to complete and
	returns the values that that process's initial function
	returned.</refpurpose>
	<refclass>Function</refclass>
      </refnamediv>

      <refsynopsisdiv>
	<synopsis><function>join-process</function> process
	&optional; default => values</synopsis>
      </refsynopsisdiv>
      
      <refsect1>
	<title>Arguments and Values</title>

	<variablelist>
	  <varlistentry>
	    <term>process</term>
	    <listitem>
	      <para>a process, typically created by <xref
	      linkend="f_process-run-function"/> or by <xref
	      linkend="f_make-process"/></para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>default</term>
	    <listitem>
	      <para>A default value to be returned if the specified
	      process doesn't exit normally.</para>
	    </listitem>
	  </varlistentry>
	  <varlistentry>
	    <term>values</term>
	    <listitem>
	      <para>The values returned by the specified process's
	      initial function if that function returns, or the value
	      of the default argument, otherwise.</para>
	    </listitem>
	  </varlistentry>
	</variablelist>
      </refsect1>

      <refsect1>
	<title>Description</title>
	<para>Waits for the specified process to terminate.  If the
	process terminates "normally" (if its initial function
	returns), returns the values that that initial function
	returnes.  If the process does not terminate normally (e.g.,
	if it's terminated via <xref linkend="f_process-kill"/> and a
	default argument is provided, returns the value of that
	default argument.  If the process doesn't terminate normally
	and no default argument is provided, signals an error.</para>
	
	<para>A process can't successfully join itself, and only one
	process can successfully receive notification of another process's
	termination.</para>
      </refsect1>
    </refentry>

  </sect1>
</chapter>
